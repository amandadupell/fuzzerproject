To start for this program, I found functions for calculating the powerset of all optional arguments and the sublists for the positional arguments. 
After that, I assembled a list of pairs, in which the pairs are optional and positional arguments. Then, for every optional and positional argument in the partial command line, you need to get the name and type from the optional argument (because each optional argument has both). I was able to do this by learning how to use list comprehension. 
I created a list of integers and strings to provide potential test values that could potentially break the program. After getting all of the values associated with the types from the arguments, I used itertools to porduct the product of all possible combinations of type values.
I created a list called commandline that I used for creating the various potential combinations of arguments and values. During this part, I used extend to add a "flattened list" of a zipped list between the optional argument names and the list of values to the commandline (made the filler blank so that the positional arguments would not be zipped to anything). To address the null values, I used list comprehension again to add things in the commandline to the final commandline. This excluded None types.
To get the Traceback, I checked for the Traceback string in the subprocess stdour and stderr. If the string was found, I printed out the commandline that caused the error.
At the end of the program, I printed a string that states how many commandlines were tested for the program (this is why I kept track of i and added 1 when generating a new commandline). 
That's it.
